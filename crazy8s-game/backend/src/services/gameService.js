const { getModels } = require('../models/database');\nconst logger = require('../utils/logger');\n\nclass GameService {\n  constructor() {\n    this.models = null;\n    this.initializeModels();\n  }\n\n  initializeModels() {\n    this.models = getModels();\n    if (this.models && Object.keys(this.models).length > 0) {\n      logger.info('GameService: Database models loaded successfully');\n    } else {\n      logger.warn('GameService: No database models available, using in-memory storage');\n    }\n  }\n\n  async saveGameHistory(gameData) {\n    try {\n      if (!this.models || !this.models.GameHistory) {\n        logger.warn('GameHistory model not available, skipping save');\n        return null;\n      }\n\n      const gameHistory = new this.models.GameHistory({\n        gameId: gameData.id,\n        players: gameData.players.map(player => ({\n          user: player.userId, // Will be null for socket-based games\n          username: player.name,\n          socketId: player.id,\n          position: player.position || 0,\n          score: player.score || 0,\n          cardsPlayed: player.cardsPlayed || 0,\n          timeSpent: player.timeSpent || 0,\n          eliminated: player.isEliminated || false,\n          eliminatedAt: player.eliminatedAt,\n          finalHand: player.hand || []\n        })),\n        winner: gameData.winner?.userId,\n        gameType: gameData.tournamentActive ? 'tournament' : 'casual',\n        duration: gameData.duration,\n        totalTurns: gameData.totalTurns,\n        startedAt: gameData.startedAt,\n        endedAt: new Date(),\n        gameSettings: {\n          timerEnabled: gameData.timerSettings?.enableTimer || false,\n          timerDuration: gameData.timerSettings?.timerDuration || 60,\n          maxPlayers: gameData.maxPlayers || 8,\n          deckSize: gameData.drawPile?.length + gameData.discardPile?.length || 52,\n          initialHandSize: 7\n        },\n        finalGameState: {\n          deck: gameData.drawPile || [],\n          discardPile: gameData.discardPile || [],\n          currentCard: gameData.getCurrentCard?.() || null,\n          currentSuit: gameData.getCurrentSuit?.() || null,\n          gamePhase: gameData.gameState\n        },\n        metadata: {\n          serverVersion: process.env.npm_package_version || '1.0.0',\n          reconnections: gameData.reconnections || 0,\n          chatMessages: gameData.chatMessages || 0\n        }\n      });\n\n      const savedGame = await gameHistory.save();\n      logger.info(`Game history saved: ${savedGame.gameId}`);\n      return savedGame;\n\n    } catch (error) {\n      logger.error('Error saving game history:', error);\n      return null;\n    }\n  }\n\n  async updatePlayerStatistics(playerId, gameResult) {\n    try {\n      if (!this.models || !this.models.User) {\n        logger.warn('User model not available, skipping statistics update');\n        return null;\n      }\n\n      const user = await this.models.User.findById(playerId);\n      if (!user) {\n        logger.warn(`User not found: ${playerId}`);\n        return null;\n      }\n\n      if (user.updateStats) {\n        await user.updateStats(gameResult);\n        logger.info(`Statistics updated for user: ${user.username}`);\n        return user;\n      } else {\n        logger.warn('updateStats method not available on user model');\n        return null;\n      }\n\n    } catch (error) {\n      logger.error('Error updating player statistics:', error);\n      return null;\n    }\n  }\n\n  async createTournament(tournamentData) {\n    try {\n      if (!this.models || !this.models.Tournament) {\n        logger.warn('Tournament model not available');\n        return null;\n      }\n\n      const tournament = new this.models.Tournament({\n        name: tournamentData.name,\n        description: tournamentData.description,\n        creator: tournamentData.creatorId,\n        type: tournamentData.type || 'single-elimination',\n        maxParticipants: tournamentData.maxParticipants || 16,\n        minParticipants: tournamentData.minParticipants || 4,\n        prize: tournamentData.prize || 'Glory and bragging rights',\n        schedule: {\n          registrationStart: new Date(),\n          registrationEnd: tournamentData.registrationEnd,\n          tournamentStart: tournamentData.startDate,\n          estimatedDuration: tournamentData.estimatedDuration\n        },\n        settings: {\n          timerEnabled: tournamentData.timerEnabled || true,\n          timerDuration: tournamentData.timerDuration || 60,\n          allowSpectators: tournamentData.allowSpectators !== false,\n          autoAdvance: tournamentData.autoAdvance !== false,\n          bestOf: tournamentData.bestOf || 1\n        }\n      });\n\n      const savedTournament = await tournament.save();\n      logger.info(`Tournament created: ${savedTournament.name} (${savedTournament.id})`);\n      return savedTournament;\n\n    } catch (error) {\n      logger.error('Error creating tournament:', error);\n      return null;\n    }\n  }\n\n  async getUserBySocketId(socketId) {\n    try {\n      if (!this.models || !this.models.User) {\n        return null;\n      }\n\n      // For now, socket-based games don't have persistent users\n      // This method is prepared for future integration\n      return null;\n\n    } catch (error) {\n      logger.error('Error getting user by socket ID:', error);\n      return null;\n    }\n  }\n\n  async getUserSettings(userId) {\n    try {\n      if (!this.models || !this.models.User) {\n        return null;\n      }\n\n      const user = await this.models.User.findById(userId);\n      if (!user) {\n        return null;\n      }\n\n      // Return settings based on database type\n      if (process.env.DB_TYPE === 'mongodb') {\n        return user.settings;\n      } else if (process.env.DB_TYPE === 'postgresql') {\n        const settings = await user.getSettings();\n        return settings;\n      }\n\n      return null;\n\n    } catch (error) {\n      logger.error('Error getting user settings:', error);\n      return null;\n    }\n  }\n\n  async updateUserSettings(userId, settingsData) {\n    try {\n      if (!this.models || !this.models.User) {\n        return null;\n      }\n\n      if (process.env.DB_TYPE === 'mongodb') {\n        const user = await this.models.User.findByIdAndUpdate(\n          userId,\n          { $set: { settings: settingsData } },\n          { new: true }\n        );\n        return user?.settings;\n      } else if (process.env.DB_TYPE === 'postgresql') {\n        const user = await this.models.User.findById(userId);\n        if (!user) return null;\n        \n        const settings = await user.getSettings();\n        if (settings) {\n          await settings.update(settingsData);\n          return settings;\n        }\n      }\n\n      return null;\n\n    } catch (error) {\n      logger.error('Error updating user settings:', error);\n      return null;\n    }\n  }\n\n  async getPlayerStatistics(userId) {\n    try {\n      if (!this.models || !this.models.GameHistory) {\n        return null;\n      }\n\n      if (process.env.DB_TYPE === 'mongodb') {\n        const stats = await this.models.GameHistory.getPlayerStats(userId);\n        return stats;\n      } else if (process.env.DB_TYPE === 'postgresql') {\n        // PostgreSQL implementation would need custom query\n        const user = await this.models.User.findById(userId);\n        if (!user) return null;\n        \n        const statistics = await user.getStatistics();\n        return statistics;\n      }\n\n      return null;\n\n    } catch (error) {\n      logger.error('Error getting player statistics:', error);\n      return null;\n    }\n  }\n\n  async getLeaderboard(options = {}) {\n    try {\n      if (!this.models || !this.models.GameHistory) {\n        return [];\n      }\n\n      if (process.env.DB_TYPE === 'mongodb') {\n        const leaderboard = await this.models.GameHistory.getLeaderboard(options);\n        return leaderboard;\n      } else if (process.env.DB_TYPE === 'postgresql') {\n        // Would need custom SQL query for PostgreSQL\n        return [];\n      }\n\n      return [];\n\n    } catch (error) {\n      logger.error('Error getting leaderboard:', error);\n      return [];\n    }\n  }\n\n  async migrateFromLocalStorage(socketId, localStorageData) {\n    try {\n      if (!this.models || !this.models.User) {\n        logger.info('User model not available, cannot migrate localStorage data');\n        return null;\n      }\n\n      logger.info(`Migrating localStorage data for socket: ${socketId}`);\n      \n      // Create a temporary user account from localStorage data\n      const userData = {\n        username: `player_${socketId.slice(-8)}`,\n        email: `${socketId.slice(-8)}@temp.crazy8s.com`,\n        password: Math.random().toString(36).slice(-8), // Temporary password\n        profile: {\n          displayName: localStorageData.playerName || `Player ${socketId.slice(-4)}`\n        },\n        settings: {\n          sortByRank: localStorageData.sortByRank || false,\n          groupBySuit: localStorageData.groupBySuit || false,\n          experiencedMode: localStorageData.experiencedMode || false,\n          enableTimer: localStorageData.enableTimer !== undefined ? localStorageData.enableTimer : true,\n          timerDuration: localStorageData.timerDuration || 60,\n          timerWarningTime: localStorageData.timerWarningTime || 15\n        }\n      };\n\n      const user = new this.models.User(userData);\n      const savedUser = await user.save();\n      \n      logger.info(`Temporary user created from localStorage: ${savedUser.username}`);\n      return savedUser;\n\n    } catch (error) {\n      logger.error('Error migrating localStorage data:', error);\n      return null;\n    }\n  }\n\n  // Health check for the service\n  getServiceHealth() {\n    return {\n      database: {\n        connected: this.models !== null,\n        type: process.env.DB_TYPE || 'none',\n        modelsAvailable: this.models ? Object.keys(this.models).length : 0\n      },\n      features: {\n        gameHistory: !!(this.models?.GameHistory),\n        userManagement: !!(this.models?.User),\n        tournaments: !!(this.models?.Tournament),\n        statistics: !!(this.models?.UserStatistics || this.models?.User)\n      }\n    };\n  }\n}\n\n// Export singleton instance\nconst gameService = new GameService();\nmodule.exports = gameService;